/* This file was generated by SableCC (http://www.sablecc.org/). */

package org.sablecc.sablecc.syntax3.lexer.analysis;

import java.util.*;
import org.sablecc.sablecc.syntax3.lexer.node.*;

public class DepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getPGrammar().apply(this);
        node.getEOF().apply(this);
        outStart(node);
    }

    public void inAGrammar(AGrammar node)
    {
        defaultIn(node);
    }

    public void outAGrammar(AGrammar node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGrammar(AGrammar node)
    {
        inAGrammar(node);
        if(node.getGrammarKeyword() != null)
        {
            node.getGrammarKeyword().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getLexer() != null)
        {
            node.getLexer().apply(this);
        }
        if(node.getParser() != null)
        {
            node.getParser().apply(this);
        }
        if(node.getTransformation() != null)
        {
            node.getTransformation().apply(this);
        }
        if(node.getTree() != null)
        {
            node.getTree().apply(this);
        }
        outAGrammar(node);
    }

    public void inALexer(ALexer node)
    {
        defaultIn(node);
    }

    public void outALexer(ALexer node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexer(ALexer node)
    {
        inALexer(node);
        if(node.getLexerKeyword() != null)
        {
            node.getLexerKeyword().apply(this);
        }
        {
            List<PNamedExpression> copy = new ArrayList<PNamedExpression>(node.getNamedExpressions());
            for(PNamedExpression e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PLexerContext> copy = new ArrayList<PLexerContext>(node.getLexerContexts());
            for(PLexerContext e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PLexerPriority> copy = new ArrayList<PLexerPriority>(node.getLexerPriorities());
            for(PLexerPriority e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PInvestigator> copy = new ArrayList<PInvestigator>(node.getInvestigators());
            for(PInvestigator e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PSelector> copy = new ArrayList<PSelector>(node.getSelectors());
            for(PSelector e : copy)
            {
                e.apply(this);
            }
        }
        outALexer(node);
    }

    public void inANamedExpression(ANamedExpression node)
    {
        defaultIn(node);
    }

    public void outANamedExpression(ANamedExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANamedExpression(ANamedExpression node)
    {
        inANamedExpression(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outANamedExpression(node);
    }

    public void inAOrExpression(AOrExpression node)
    {
        defaultIn(node);
    }

    public void outAOrExpression(AOrExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOrExpression(AOrExpression node)
    {
        inAOrExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getBar() != null)
        {
            node.getBar().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAOrExpression(node);
    }

    public void inAConcatenationExpression(AConcatenationExpression node)
    {
        defaultIn(node);
    }

    public void outAConcatenationExpression(AConcatenationExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAConcatenationExpression(AConcatenationExpression node)
    {
        inAConcatenationExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAConcatenationExpression(node);
    }

    public void inALookExpression(ALookExpression node)
    {
        defaultIn(node);
    }

    public void outALookExpression(ALookExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookExpression(ALookExpression node)
    {
        inALookExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getLookback() != null)
        {
            node.getLookback().apply(this);
        }
        if(node.getLookahead() != null)
        {
            node.getLookahead().apply(this);
        }
        outALookExpression(node);
    }

    public void inAShortestExpression(AShortestExpression node)
    {
        defaultIn(node);
    }

    public void outAShortestExpression(AShortestExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAShortestExpression(AShortestExpression node)
    {
        inAShortestExpression(node);
        if(node.getShortestKeyword() != null)
        {
            node.getShortestKeyword().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outAShortestExpression(node);
    }

    public void inALongestExpression(ALongestExpression node)
    {
        defaultIn(node);
    }

    public void outALongestExpression(ALongestExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALongestExpression(ALongestExpression node)
    {
        inALongestExpression(node);
        if(node.getLongestKeyword() != null)
        {
            node.getLongestKeyword().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outALongestExpression(node);
    }

    public void inASubtractionExpression(ASubtractionExpression node)
    {
        defaultIn(node);
    }

    public void outASubtractionExpression(ASubtractionExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASubtractionExpression(ASubtractionExpression node)
    {
        inASubtractionExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getMinus() != null)
        {
            node.getMinus().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outASubtractionExpression(node);
    }

    public void inAExceptExpression(AExceptExpression node)
    {
        defaultIn(node);
    }

    public void outAExceptExpression(AExceptExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAExceptExpression(AExceptExpression node)
    {
        inAExceptExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getExceptKeyword() != null)
        {
            node.getExceptKeyword().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAExceptExpression(node);
    }

    public void inAIntersectionExpression(AIntersectionExpression node)
    {
        defaultIn(node);
    }

    public void outAIntersectionExpression(AIntersectionExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntersectionExpression(AIntersectionExpression node)
    {
        inAIntersectionExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getAndKeyword() != null)
        {
            node.getAndKeyword().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAIntersectionExpression(node);
    }

    public void inAUnaryOperatorExpression(AUnaryOperatorExpression node)
    {
        defaultIn(node);
    }

    public void outAUnaryOperatorExpression(AUnaryOperatorExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnaryOperatorExpression(AUnaryOperatorExpression node)
    {
        inAUnaryOperatorExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getUnaryOperator() != null)
        {
            node.getUnaryOperator().apply(this);
        }
        outAUnaryOperatorExpression(node);
    }

    public void inASeparatedExpression(ASeparatedExpression node)
    {
        defaultIn(node);
    }

    public void outASeparatedExpression(ASeparatedExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedExpression(ASeparatedExpression node)
    {
        inASeparatedExpression(node);
        if(node.getBase() != null)
        {
            node.getBase().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getManyOperator() != null)
        {
            node.getManyOperator().apply(this);
        }
        outASeparatedExpression(node);
    }

    public void inAUnitExpression(AUnitExpression node)
    {
        defaultIn(node);
    }

    public void outAUnitExpression(AUnitExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnitExpression(AUnitExpression node)
    {
        inAUnitExpression(node);
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAUnitExpression(node);
    }

    public void inAEpsilonExpression(AEpsilonExpression node)
    {
        defaultIn(node);
    }

    public void outAEpsilonExpression(AEpsilonExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEpsilonExpression(AEpsilonExpression node)
    {
        inAEpsilonExpression(node);
        if(node.getEpsilon() != null)
        {
            node.getEpsilon().apply(this);
        }
        outAEpsilonExpression(node);
    }

    public void inAIntervalExpression(AIntervalExpression node)
    {
        defaultIn(node);
    }

    public void outAIntervalExpression(AIntervalExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalExpression(AIntervalExpression node)
    {
        inAIntervalExpression(node);
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getTwoDots() != null)
        {
            node.getTwoDots().apply(this);
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        outAIntervalExpression(node);
    }

    public void inAAnyExpression(AAnyExpression node)
    {
        defaultIn(node);
    }

    public void outAAnyExpression(AAnyExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAnyExpression(AAnyExpression node)
    {
        inAAnyExpression(node);
        if(node.getAnyKeyword() != null)
        {
            node.getAnyKeyword().apply(this);
        }
        outAAnyExpression(node);
    }

    public void inALookback(ALookback node)
    {
        defaultIn(node);
    }

    public void outALookback(ALookback node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookback(ALookback node)
    {
        inALookback(node);
        if(node.getLookbackKeyword() != null)
        {
            node.getLookbackKeyword().apply(this);
        }
        if(node.getNotKeyword() != null)
        {
            node.getNotKeyword().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outALookback(node);
    }

    public void inALookahead(ALookahead node)
    {
        defaultIn(node);
    }

    public void outALookahead(ALookahead node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookahead(ALookahead node)
    {
        inALookahead(node);
        if(node.getLookaheadKeyword() != null)
        {
            node.getLookaheadKeyword().apply(this);
        }
        if(node.getNotKeyword() != null)
        {
            node.getNotKeyword().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outALookahead(node);
    }

    public void inACharCharacter(ACharCharacter node)
    {
        defaultIn(node);
    }

    public void outACharCharacter(ACharCharacter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharCharacter(ACharCharacter node)
    {
        inACharCharacter(node);
        if(node.getChar() != null)
        {
            node.getChar().apply(this);
        }
        outACharCharacter(node);
    }

    public void inADecCharacter(ADecCharacter node)
    {
        defaultIn(node);
    }

    public void outADecCharacter(ADecCharacter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADecCharacter(ADecCharacter node)
    {
        inADecCharacter(node);
        if(node.getDecChar() != null)
        {
            node.getDecChar().apply(this);
        }
        outADecCharacter(node);
    }

    public void inAHexCharacter(AHexCharacter node)
    {
        defaultIn(node);
    }

    public void outAHexCharacter(AHexCharacter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAHexCharacter(AHexCharacter node)
    {
        inAHexCharacter(node);
        if(node.getHexChar() != null)
        {
            node.getHexChar().apply(this);
        }
        outAHexCharacter(node);
    }

    public void inANameUnit(ANameUnit node)
    {
        defaultIn(node);
    }

    public void outANameUnit(ANameUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANameUnit(ANameUnit node)
    {
        inANameUnit(node);
        if(node.getIdentifier() != null)
        {
            node.getIdentifier().apply(this);
        }
        outANameUnit(node);
    }

    public void inAStringUnit(AStringUnit node)
    {
        defaultIn(node);
    }

    public void outAStringUnit(AStringUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStringUnit(AStringUnit node)
    {
        inAStringUnit(node);
        if(node.getString() != null)
        {
            node.getString().apply(this);
        }
        outAStringUnit(node);
    }

    public void inACharacterUnit(ACharacterUnit node)
    {
        defaultIn(node);
    }

    public void outACharacterUnit(ACharacterUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharacterUnit(ACharacterUnit node)
    {
        inACharacterUnit(node);
        if(node.getCharacter() != null)
        {
            node.getCharacter().apply(this);
        }
        outACharacterUnit(node);
    }

    public void inAStartUnit(AStartUnit node)
    {
        defaultIn(node);
    }

    public void outAStartUnit(AStartUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStartUnit(AStartUnit node)
    {
        inAStartUnit(node);
        if(node.getStartKeyword() != null)
        {
            node.getStartKeyword().apply(this);
        }
        outAStartUnit(node);
    }

    public void inAEndUnit(AEndUnit node)
    {
        defaultIn(node);
    }

    public void outAEndUnit(AEndUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEndUnit(AEndUnit node)
    {
        inAEndUnit(node);
        if(node.getEndKeyword() != null)
        {
            node.getEndKeyword().apply(this);
        }
        outAEndUnit(node);
    }

    public void inALexerPriority(ALexerPriority node)
    {
        defaultIn(node);
    }

    public void outALexerPriority(ALexerPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerPriority(ALexerPriority node)
    {
        inALexerPriority(node);
        if(node.getHigh() != null)
        {
            node.getHigh().apply(this);
        }
        if(node.getGt() != null)
        {
            node.getGt().apply(this);
        }
        if(node.getLow() != null)
        {
            node.getLow().apply(this);
        }
        outALexerPriority(node);
    }

    public void inALexerContext(ALexerContext node)
    {
        defaultIn(node);
    }

    public void outALexerContext(ALexerContext node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerContext(ALexerContext node)
    {
        inALexerContext(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getTokens() != null)
        {
            node.getTokens().apply(this);
        }
        if(node.getIgnored() != null)
        {
            node.getIgnored().apply(this);
        }
        outALexerContext(node);
    }

    public void inATokens(ATokens node)
    {
        defaultIn(node);
    }

    public void outATokens(ATokens node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokens(ATokens node)
    {
        inATokens(node);
        if(node.getTokenKeyword() != null)
        {
            node.getTokenKeyword().apply(this);
        }
        {
            List<PUnit> copy = new ArrayList<PUnit>(node.getUnits());
            for(PUnit e : copy)
            {
                e.apply(this);
            }
        }
        outATokens(node);
    }

    public void inAIgnored(AIgnored node)
    {
        defaultIn(node);
    }

    public void outAIgnored(AIgnored node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIgnored(AIgnored node)
    {
        inAIgnored(node);
        if(node.getIgnoredKeyword() != null)
        {
            node.getIgnoredKeyword().apply(this);
        }
        {
            List<PUnit> copy = new ArrayList<PUnit>(node.getUnits());
            for(PUnit e : copy)
            {
                e.apply(this);
            }
        }
        outAIgnored(node);
    }

    public void inAInvestigator(AInvestigator node)
    {
        defaultIn(node);
    }

    public void outAInvestigator(AInvestigator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInvestigator(AInvestigator node)
    {
        inAInvestigator(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outAInvestigator(node);
    }

    public void inASelector(ASelector node)
    {
        defaultIn(node);
    }

    public void outASelector(ASelector node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASelector(ASelector node)
    {
        inASelector(node);
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getNames());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        if(node.getSelectorName() != null)
        {
            node.getSelectorName().apply(this);
        }
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outASelector(node);
    }

    public void inAParser(AParser node)
    {
        defaultIn(node);
    }

    public void outAParser(AParser node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParser(AParser node)
    {
        inAParser(node);
        if(node.getParserKeyword() != null)
        {
            node.getParserKeyword().apply(this);
        }
        if(node.getRoot() != null)
        {
            node.getRoot().apply(this);
        }
        {
            List<PParserContext> copy = new ArrayList<PParserContext>(node.getParserContexts());
            for(PParserContext e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PInvestigator> copy = new ArrayList<PInvestigator>(node.getInvestigators());
            for(PInvestigator e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PSelector> copy = new ArrayList<PSelector>(node.getSelectors());
            for(PSelector e : copy)
            {
                e.apply(this);
            }
        }
        outAParser(node);
    }

    public void inARoot(ARoot node)
    {
        defaultIn(node);
    }

    public void outARoot(ARoot node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARoot(ARoot node)
    {
        inARoot(node);
        if(node.getRootKeyword() != null)
        {
            node.getRootKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outARoot(node);
    }

    public void inAParserContext(AParserContext node)
    {
        defaultIn(node);
    }

    public void outAParserContext(AParserContext node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserContext(AParserContext node)
    {
        inAParserContext(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        {
            List<PParserProduction> copy = new ArrayList<PParserProduction>(node.getParserProductions());
            for(PParserProduction e : copy)
            {
                e.apply(this);
            }
        }
        outAParserContext(node);
    }

    public void inAParserProduction(AParserProduction node)
    {
        defaultIn(node);
    }

    public void outAParserProduction(AParserProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserProduction(AParserProduction node)
    {
        inAParserProduction(node);
        if(node.getQualifier() != null)
        {
            node.getQualifier().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        {
            List<PParserAlternative> copy = new ArrayList<PParserAlternative>(node.getParserAlternatives());
            for(PParserAlternative e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PParserPriority> copy = new ArrayList<PParserPriority>(node.getParserPriorities());
            for(PParserPriority e : copy)
            {
                e.apply(this);
            }
        }
        outAParserProduction(node);
    }

    public void inADanglingQualifier(ADanglingQualifier node)
    {
        defaultIn(node);
    }

    public void outADanglingQualifier(ADanglingQualifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADanglingQualifier(ADanglingQualifier node)
    {
        inADanglingQualifier(node);
        if(node.getDanglingKeyword() != null)
        {
            node.getDanglingKeyword().apply(this);
        }
        outADanglingQualifier(node);
    }

    public void inATokenQualifier(ATokenQualifier node)
    {
        defaultIn(node);
    }

    public void outATokenQualifier(ATokenQualifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenQualifier(ATokenQualifier node)
    {
        inATokenQualifier(node);
        if(node.getTokenKeyword() != null)
        {
            node.getTokenKeyword().apply(this);
        }
        outATokenQualifier(node);
    }

    public void inAParserAlternative(AParserAlternative node)
    {
        defaultIn(node);
    }

    public void outAParserAlternative(AParserAlternative node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserAlternative(AParserAlternative node)
    {
        inAParserAlternative(node);
        if(node.getAlternativeName() != null)
        {
            node.getAlternativeName().apply(this);
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getDanglingElement() != null)
        {
            node.getDanglingElement().apply(this);
        }
        outAParserAlternative(node);
    }

    public void inANormalElement(ANormalElement node)
    {
        defaultIn(node);
    }

    public void outANormalElement(ANormalElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANormalElement(ANormalElement node)
    {
        inANormalElement(node);
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        if(node.getUnaryOperator() != null)
        {
            node.getUnaryOperator().apply(this);
        }
        outANormalElement(node);
    }

    public void inASeparatedElement(ASeparatedElement node)
    {
        defaultIn(node);
    }

    public void outASeparatedElement(ASeparatedElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedElement(ASeparatedElement node)
    {
        inASeparatedElement(node);
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getManyOperator() != null)
        {
            node.getManyOperator().apply(this);
        }
        outASeparatedElement(node);
    }

    public void inAAlternatedElement(AAlternatedElement node)
    {
        defaultIn(node);
    }

    public void outAAlternatedElement(AAlternatedElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlternatedElement(AAlternatedElement node)
    {
        inAAlternatedElement(node);
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getManyOperator() != null)
        {
            node.getManyOperator().apply(this);
        }
        outAAlternatedElement(node);
    }

    public void inAZeroOrOneUnaryOperator(AZeroOrOneUnaryOperator node)
    {
        defaultIn(node);
    }

    public void outAZeroOrOneUnaryOperator(AZeroOrOneUnaryOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrOneUnaryOperator(AZeroOrOneUnaryOperator node)
    {
        inAZeroOrOneUnaryOperator(node);
        if(node.getQMark() != null)
        {
            node.getQMark().apply(this);
        }
        outAZeroOrOneUnaryOperator(node);
    }

    public void inAManyUnaryOperator(AManyUnaryOperator node)
    {
        defaultIn(node);
    }

    public void outAManyUnaryOperator(AManyUnaryOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAManyUnaryOperator(AManyUnaryOperator node)
    {
        inAManyUnaryOperator(node);
        if(node.getManyOperator() != null)
        {
            node.getManyOperator().apply(this);
        }
        outAManyUnaryOperator(node);
    }

    public void inAZeroOrMoreManyOperator(AZeroOrMoreManyOperator node)
    {
        defaultIn(node);
    }

    public void outAZeroOrMoreManyOperator(AZeroOrMoreManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrMoreManyOperator(AZeroOrMoreManyOperator node)
    {
        inAZeroOrMoreManyOperator(node);
        if(node.getStar() != null)
        {
            node.getStar().apply(this);
        }
        outAZeroOrMoreManyOperator(node);
    }

    public void inAOneOrMoreManyOperator(AOneOrMoreManyOperator node)
    {
        defaultIn(node);
    }

    public void outAOneOrMoreManyOperator(AOneOrMoreManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOneOrMoreManyOperator(AOneOrMoreManyOperator node)
    {
        inAOneOrMoreManyOperator(node);
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outAOneOrMoreManyOperator(node);
    }

    public void inANumberManyOperator(ANumberManyOperator node)
    {
        defaultIn(node);
    }

    public void outANumberManyOperator(ANumberManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberManyOperator(ANumberManyOperator node)
    {
        inANumberManyOperator(node);
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        outANumberManyOperator(node);
    }

    public void inAIntervalManyOperator(AIntervalManyOperator node)
    {
        defaultIn(node);
    }

    public void outAIntervalManyOperator(AIntervalManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalManyOperator(AIntervalManyOperator node)
    {
        inAIntervalManyOperator(node);
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getTwoDots() != null)
        {
            node.getTwoDots().apply(this);
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outAIntervalManyOperator(node);
    }

    public void inAAtLeastManyOperator(AAtLeastManyOperator node)
    {
        defaultIn(node);
    }

    public void outAAtLeastManyOperator(AAtLeastManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAtLeastManyOperator(AAtLeastManyOperator node)
    {
        inAAtLeastManyOperator(node);
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getThreeDots() != null)
        {
            node.getThreeDots().apply(this);
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outAAtLeastManyOperator(node);
    }

    public void inADanglingElement(ADanglingElement node)
    {
        defaultIn(node);
    }

    public void outADanglingElement(ADanglingElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADanglingElement(ADanglingElement node)
    {
        inADanglingElement(node);
        if(node.getDanglingKeyword() != null)
        {
            node.getDanglingKeyword().apply(this);
        }
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getIdentifier() != null)
        {
            node.getIdentifier().apply(this);
        }
        if(node.getQMark() != null)
        {
            node.getQMark().apply(this);
        }
        outADanglingElement(node);
    }

    public void inALeftParserPriority(ALeftParserPriority node)
    {
        defaultIn(node);
    }

    public void outALeftParserPriority(ALeftParserPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALeftParserPriority(ALeftParserPriority node)
    {
        inALeftParserPriority(node);
        if(node.getLeftKeyword() != null)
        {
            node.getLeftKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outALeftParserPriority(node);
    }

    public void inARightParserPriority(ARightParserPriority node)
    {
        defaultIn(node);
    }

    public void outARightParserPriority(ARightParserPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARightParserPriority(ARightParserPriority node)
    {
        inARightParserPriority(node);
        if(node.getRightKeyword() != null)
        {
            node.getRightKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outARightParserPriority(node);
    }

    public void inAUnaryParserPriority(AUnaryParserPriority node)
    {
        defaultIn(node);
    }

    public void outAUnaryParserPriority(AUnaryParserPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnaryParserPriority(AUnaryParserPriority node)
    {
        inAUnaryParserPriority(node);
        if(node.getUnaryKeyword() != null)
        {
            node.getUnaryKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outAUnaryParserPriority(node);
    }

    public void inATransformation(ATransformation node)
    {
        defaultIn(node);
    }

    public void outATransformation(ATransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATransformation(ATransformation node)
    {
        inATransformation(node);
        if(node.getTransformationKeyword() != null)
        {
            node.getTransformationKeyword().apply(this);
        }
        if(node.getProductionTransformations() != null)
        {
            node.getProductionTransformations().apply(this);
        }
        if(node.getAlternativeTransformations() != null)
        {
            node.getAlternativeTransformations().apply(this);
        }
        outATransformation(node);
    }

    public void inAProductionTransformations(AProductionTransformations node)
    {
        defaultIn(node);
    }

    public void outAProductionTransformations(AProductionTransformations node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProductionTransformations(AProductionTransformations node)
    {
        inAProductionTransformations(node);
        if(node.getProductionKeyword() != null)
        {
            node.getProductionKeyword().apply(this);
        }
        {
            List<PProductionTransformation> copy = new ArrayList<PProductionTransformation>(node.getProductionTransformations());
            for(PProductionTransformation e : copy)
            {
                e.apply(this);
            }
        }
        outAProductionTransformations(node);
    }

    public void inAProductionTransformation(AProductionTransformation node)
    {
        defaultIn(node);
    }

    public void outAProductionTransformation(AProductionTransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProductionTransformation(AProductionTransformation node)
    {
        inAProductionTransformation(node);
        if(node.getProduction() != null)
        {
            node.getProduction().apply(this);
        }
        if(node.getArrow() != null)
        {
            node.getArrow().apply(this);
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        outAProductionTransformation(node);
    }

    public void inAAlternativeTransformations(AAlternativeTransformations node)
    {
        defaultIn(node);
    }

    public void outAAlternativeTransformations(AAlternativeTransformations node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlternativeTransformations(AAlternativeTransformations node)
    {
        inAAlternativeTransformations(node);
        if(node.getAlternativeKeyword() != null)
        {
            node.getAlternativeKeyword().apply(this);
        }
        {
            List<PAlternativeTransformation> copy = new ArrayList<PAlternativeTransformation>(node.getAlternativeTransformations());
            for(PAlternativeTransformation e : copy)
            {
                e.apply(this);
            }
        }
        outAAlternativeTransformations(node);
    }

    public void inAAlternativeTransformation(AAlternativeTransformation node)
    {
        defaultIn(node);
    }

    public void outAAlternativeTransformation(AAlternativeTransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlternativeTransformation(AAlternativeTransformation node)
    {
        inAAlternativeTransformation(node);
        if(node.getAlternativeReference() != null)
        {
            node.getAlternativeReference().apply(this);
        }
        if(node.getArrow() != null)
        {
            node.getArrow().apply(this);
        }
        {
            List<PTransformationElement> copy = new ArrayList<PTransformationElement>(node.getTransformationElements());
            for(PTransformationElement e : copy)
            {
                e.apply(this);
            }
        }
        outAAlternativeTransformation(node);
    }

    public void inAUnnamedAlternativeReference(AUnnamedAlternativeReference node)
    {
        defaultIn(node);
    }

    public void outAUnnamedAlternativeReference(AUnnamedAlternativeReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnnamedAlternativeReference(AUnnamedAlternativeReference node)
    {
        inAUnnamedAlternativeReference(node);
        if(node.getProduction() != null)
        {
            node.getProduction().apply(this);
        }
        outAUnnamedAlternativeReference(node);
    }

    public void inANamedAlternativeReference(ANamedAlternativeReference node)
    {
        defaultIn(node);
    }

    public void outANamedAlternativeReference(ANamedAlternativeReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANamedAlternativeReference(ANamedAlternativeReference node)
    {
        inANamedAlternativeReference(node);
        if(node.getProduction() != null)
        {
            node.getProduction().apply(this);
        }
        if(node.getDot() != null)
        {
            node.getDot().apply(this);
        }
        if(node.getAlternative() != null)
        {
            node.getAlternative().apply(this);
        }
        outANamedAlternativeReference(node);
    }

    public void inANullTransformationElement(ANullTransformationElement node)
    {
        defaultIn(node);
    }

    public void outANullTransformationElement(ANullTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANullTransformationElement(ANullTransformationElement node)
    {
        inANullTransformationElement(node);
        if(node.getNullKeyword() != null)
        {
            node.getNullKeyword().apply(this);
        }
        outANullTransformationElement(node);
    }

    public void inAReferenceTransformationElement(AReferenceTransformationElement node)
    {
        defaultIn(node);
    }

    public void outAReferenceTransformationElement(AReferenceTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReferenceTransformationElement(AReferenceTransformationElement node)
    {
        inAReferenceTransformationElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        outAReferenceTransformationElement(node);
    }

    public void inANewTransformationElement(ANewTransformationElement node)
    {
        defaultIn(node);
    }

    public void outANewTransformationElement(ANewTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANewTransformationElement(ANewTransformationElement node)
    {
        inANewTransformationElement(node);
        if(node.getNewKeyword() != null)
        {
            node.getNewKeyword().apply(this);
        }
        if(node.getAlternativeReference() != null)
        {
            node.getAlternativeReference().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        {
            List<PTransformationElement> copy = new ArrayList<PTransformationElement>(node.getTransformationElements());
            for(PTransformationElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outANewTransformationElement(node);
    }

    public void inAListTransformationElement(AListTransformationElement node)
    {
        defaultIn(node);
    }

    public void outAListTransformationElement(AListTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAListTransformationElement(AListTransformationElement node)
    {
        inAListTransformationElement(node);
        if(node.getListKeyword() != null)
        {
            node.getListKeyword().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        {
            List<PListElement> copy = new ArrayList<PListElement>(node.getListElements());
            for(PListElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outAListTransformationElement(node);
    }

    public void inAReferenceListElement(AReferenceListElement node)
    {
        defaultIn(node);
    }

    public void outAReferenceListElement(AReferenceListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReferenceListElement(AReferenceListElement node)
    {
        inAReferenceListElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        outAReferenceListElement(node);
    }

    public void inAListReferenceListElement(AListReferenceListElement node)
    {
        defaultIn(node);
    }

    public void outAListReferenceListElement(AListReferenceListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAListReferenceListElement(AListReferenceListElement node)
    {
        inAListReferenceListElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        if(node.getThreeDots() != null)
        {
            node.getThreeDots().apply(this);
        }
        outAListReferenceListElement(node);
    }

    public void inALeftListReferenceListElement(ALeftListReferenceListElement node)
    {
        defaultIn(node);
    }

    public void outALeftListReferenceListElement(ALeftListReferenceListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALeftListReferenceListElement(ALeftListReferenceListElement node)
    {
        inALeftListReferenceListElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        if(node.getLeftKeyword() != null)
        {
            node.getLeftKeyword().apply(this);
        }
        outALeftListReferenceListElement(node);
    }

    public void inARightListReferenceListElement(ARightListReferenceListElement node)
    {
        defaultIn(node);
    }

    public void outARightListReferenceListElement(ARightListReferenceListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARightListReferenceListElement(ARightListReferenceListElement node)
    {
        inARightListReferenceListElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        if(node.getRightKeyword() != null)
        {
            node.getRightKeyword().apply(this);
        }
        outARightListReferenceListElement(node);
    }

    public void inANewListElement(ANewListElement node)
    {
        defaultIn(node);
    }

    public void outANewListElement(ANewListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANewListElement(ANewListElement node)
    {
        inANewListElement(node);
        if(node.getNewKeyword() != null)
        {
            node.getNewKeyword().apply(this);
        }
        if(node.getAlternativeReference() != null)
        {
            node.getAlternativeReference().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        {
            List<PTransformationElement> copy = new ArrayList<PTransformationElement>(node.getTransformationElements());
            for(PTransformationElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outANewListElement(node);
    }

    public void inANaturalElementReference(ANaturalElementReference node)
    {
        defaultIn(node);
    }

    public void outANaturalElementReference(ANaturalElementReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANaturalElementReference(ANaturalElementReference node)
    {
        inANaturalElementReference(node);
        if(node.getElement() != null)
        {
            node.getElement().apply(this);
        }
        outANaturalElementReference(node);
    }

    public void inATransformedElementReference(ATransformedElementReference node)
    {
        defaultIn(node);
    }

    public void outATransformedElementReference(ATransformedElementReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATransformedElementReference(ATransformedElementReference node)
    {
        inATransformedElementReference(node);
        if(node.getElement() != null)
        {
            node.getElement().apply(this);
        }
        if(node.getDot() != null)
        {
            node.getDot().apply(this);
        }
        if(node.getPart() != null)
        {
            node.getPart().apply(this);
        }
        outATransformedElementReference(node);
    }

    public void inATree(ATree node)
    {
        defaultIn(node);
    }

    public void outATree(ATree node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATree(ATree node)
    {
        inATree(node);
        if(node.getTreeKeyword() != null)
        {
            node.getTreeKeyword().apply(this);
        }
        {
            List<PTreeProduction> copy = new ArrayList<PTreeProduction>(node.getTreeProductions());
            for(PTreeProduction e : copy)
            {
                e.apply(this);
            }
        }
        outATree(node);
    }

    public void inATreeProduction(ATreeProduction node)
    {
        defaultIn(node);
    }

    public void outATreeProduction(ATreeProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATreeProduction(ATreeProduction node)
    {
        inATreeProduction(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        {
            List<PTreeAlternative> copy = new ArrayList<PTreeAlternative>(node.getTreeAlternatives());
            for(PTreeAlternative e : copy)
            {
                e.apply(this);
            }
        }
        outATreeProduction(node);
    }

    public void inATreeAlternative(ATreeAlternative node)
    {
        defaultIn(node);
    }

    public void outATreeAlternative(ATreeAlternative node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATreeAlternative(ATreeAlternative node)
    {
        inATreeAlternative(node);
        if(node.getAlternativeName() != null)
        {
            node.getAlternativeName().apply(this);
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        outATreeAlternative(node);
    }
}
